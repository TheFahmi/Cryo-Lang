// ============================================
// ARGON STANDARD LIBRARY: CHANNEL (v3.0.0)
// Simplified Channel-based communication
// ============================================

let CHANNEL_VERSION = "3.0.0";

// Channel struct
struct Channel {
    buffer: any,
    capacity: int,
    closed: bool
}

// Create unbuffered channel
fn channel() {
    return Channel {
        buffer: [],
        capacity: 0,
        closed: false
    };
}

// Create buffered channel
fn bufferedChannel(cap) {
    return Channel {
        buffer: [],
        capacity: cap,
        closed: false
    };
}

// Send value to channel
fn send(ch, value) {
    if (ch.closed) {
        return false;
    }
    push(ch.buffer, value);
    return true;
}

// Try send without blocking
fn trySend(ch, value) {
    if (ch.closed) {
        return false;
    }
    if (ch.capacity > 0 && len(ch.buffer) >= ch.capacity) {
        return false;
    }
    push(ch.buffer, value);
    return true;
}

// Receive result struct
struct RecvResult {
    value: any,
    ok: bool
}

// Receive from channel
fn recv(ch) {
    if (len(ch.buffer) == 0) {
        return RecvResult { value: null, ok: false };
    }
    
    let value = ch.buffer[0];
    let newBuffer = [];
    let i = 1;
    while (i < len(ch.buffer)) {
        push(newBuffer, ch.buffer[i]);
        i = i + 1;
    }
    ch.buffer = newBuffer;
    
    return RecvResult { value: value, ok: true };
}

// Try receive without blocking
fn tryRecv(ch) {
    return recv(ch);
}

// Close channel
fn close(ch) {
    ch.closed = true;
}

// Check if closed
fn isClosed(ch) {
    return ch.closed;
}

// Get pending count
fn pending(ch) {
    return len(ch.buffer);
}
