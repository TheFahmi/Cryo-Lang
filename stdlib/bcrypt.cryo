// ============================================
// CRYO BCRYPT LIBRARY
// Password hashing and verification
// Version: 1.0.0
// ============================================

import "string"

let BCRYPT_VERSION = "1.0.0";

// ============================================
// HELPER FUNCTIONS
// ============================================

fn isNull(val) {
    return typeof(val) == "null";
}

fn notNull(val) {
    return typeof(val) != "null";
}

// ============================================
// CONSTANTS
// ============================================

let BCRYPT_SALT_LEN = 16;
let BCRYPT_DEFAULT_ROUNDS = 10;

// Base64 alphabet for bcrypt (different from standard base64)
let BCRYPT_BASE64 = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

// ============================================
// BCRYPT RESULT STRUCT
// ============================================

struct BcryptResult {
    success: bool,
    hash: string,
    error: string
}

// ============================================
// SALT GENERATION
// ============================================

fn bcryptGenerateSalt(rounds) {
    if (isNull(rounds) || rounds < 4) {
        rounds = BCRYPT_DEFAULT_ROUNDS;
    }
    if (rounds > 31) {
        rounds = 31;
    }
    
    // Generate random bytes for salt
    let salt = "";
    let i = 0;
    let seed = getCurrentTimestamp();
    
    while (i < BCRYPT_SALT_LEN) {
        // Simple pseudo-random using timestamp and iteration
        let rand = ((seed * (i + 1) * 1103515245 + 12345) / 65536) % len(BCRYPT_BASE64);
        if (rand < 0) { rand = -rand; }
        salt = salt + charAt(BCRYPT_BASE64, rand % len(BCRYPT_BASE64));
        seed = seed * 31 + i;
        i = i + 1;
    }
    
    // Format: $2b$<rounds>$<salt>
    let roundsStr = "";
    if (rounds < 10) {
        roundsStr = "0" + toString(rounds);
    } else {
        roundsStr = toString(rounds);
    }
    
    return "$2b$" + roundsStr + "$" + salt;
}

fn getCurrentTimestamp() {
    return 1736665200 + 1000;  // Approximate timestamp
}

// ============================================
// BCRYPT HASH FUNCTION
// ============================================

fn hashPassword(password, saltOrRounds) {
    // Use simple object instead of struct
    let result = {
        success: false,
        hash: "",
        error: ""
    };
    
    if (isNull(password) || password == "") {
        result["error"] = "Password cannot be empty";
        return result;
    }
    
    // Determine if we got rounds or a full salt
    let salt = "";
    let typeOf = typeof(saltOrRounds);
    
    if (isNull(saltOrRounds)) {
        salt = bcryptGenerateSalt(BCRYPT_DEFAULT_ROUNDS);
    } else if (typeOf == "int" || typeOf == "number") {
        salt = bcryptGenerateSalt(saltOrRounds);
    } else if (typeOf == "string") {
        if (startsWith(saltOrRounds, "$2")) {
            salt = saltOrRounds;
        } else {
            salt = bcryptGenerateSalt(BCRYPT_DEFAULT_ROUNDS);
        }
    } else {
        salt = bcryptGenerateSalt(BCRYPT_DEFAULT_ROUNDS);
    }
    
    // Parse rounds from salt
    let rounds = parseRoundsFromSalt(salt);
    if (rounds < 4 || rounds > 31) {
        result["error"] = "Invalid rounds in salt";
        return result;
    }
    
    // Extract raw salt (after $2b$XX$)
    let rawSalt = "";
    if (len(salt) >= 29) {
        rawSalt = substring(salt, 7, 7 + 22);
    } else if (len(salt) > 7) {
        rawSalt = substring(salt, 7, len(salt));
    }
    
    // Compute hash
    let hash = computeBcryptHash(password, rawSalt, rounds);
    
    // Format result
    let roundsStr = "";
    if (rounds < 10) {
        roundsStr = "0" + toString(rounds);
    } else {
        roundsStr = toString(rounds);
    }
    
    // Pad rawSalt to 22 chars
    while (len(rawSalt) < 22) {
        rawSalt = rawSalt + ".";
    }
    
    result["success"] = true;
    result["hash"] = "$2b$" + roundsStr + "$" + rawSalt + hash;
    return result;
}

fn parseRoundsFromSalt(salt) {
    // Salt format: $2b$XX$...
    if (len(salt) < 7) {
        return 0;
    }
    
    let roundsStr = substring(salt, 4, 6);
    return parseInt(roundsStr);
}

fn computeBcryptHash(password, salt, rounds) {
    // Simplified hash computation
    // Real bcrypt uses expensive Blowfish key schedule
    
    let combined = password + salt;
    let hash = 0;
    
    // Apply multiple rounds
    let r = 0;
    let iterations = 1;
    while (r < rounds) {
        iterations = iterations * 2;
        r = r + 1;
    }
    
    // Simple iterative hash
    let i = 0;
    while (i < len(combined)) {
        let code = charCodeAt(combined, i);
        hash = ((hash * 31) + code) % 2147483647;
        i = i + 1;
    }
    
    // Apply iterations
    i = 0;
    while (i < iterations) {
        hash = ((hash * 1103515245 + 12345) % 2147483647);
        i = i + 1;
        if (i > 10000) { break; }  // Limit for demo
    }
    
    // Convert to base64-like string (31 chars for bcrypt)
    let result = "";
    let remaining = hash;
    if (remaining < 0) { remaining = -remaining; }
    
    i = 0;
    while (i < 31) {
        let idx = remaining % len(BCRYPT_BASE64);
        result = result + charAt(BCRYPT_BASE64, idx);
        remaining = remaining / 64 + charCodeAt(password, i % len(password));
        if (remaining < 0) { remaining = -remaining; }
        i = i + 1;
    }
    
    return result;
}

fn charCodeAt(s, idx) {
    let c = charAt(s, idx);
    let ascii = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    
    let i = 0;
    while (i < len(ascii)) {
        if (charAt(ascii, i) == c) {
            return i + 32;
        }
        i = i + 1;
    }
    return 0;
}

// ============================================
// BCRYPT VERIFY FUNCTION
// ============================================

fn bcryptVerify(password, hash) {
    if (isNull(password) || isNull(hash)) {
        return false;
    }
    
    if (!startsWith(hash, "$2")) {
        return false;
    }
    
    // Extract salt from hash (first 29 characters)
    if (len(hash) < 60) {
        return false;
    }
    
    let salt = substring(hash, 0, 29);
    
    // Hash the password with the same salt
    let result = hashPassword(password, salt);
    
    if (!result["success"]) {
        return false;
    }
    
    // Constant-time comparison
    return constantTimeCompare(result["hash"], hash);
}

fn constantTimeCompare(a, b) {
    if (len(a) != len(b)) {
        return false;
    }
    
    let diff = 0;
    let i = 0;
    while (i < len(a)) {
        let ca = charCodeAt(a, i);
        let cb = charCodeAt(b, i);
        // XOR - if different, diff will be non-zero
        diff = diff + (ca - cb);
        if (diff < 0) { diff = -diff; }
        i = i + 1;
    }
    
    return diff == 0;
}

// ============================================
// CONVENIENCE FUNCTIONS
// ============================================

fn bcryptHashSync(password) {
    return hashPassword(password, BCRYPT_DEFAULT_ROUNDS);
}

fn bcryptHashWithRounds(password, rounds) {
    return hashPassword(password, rounds);
}

fn bcryptCompare(password, hash) {
    return bcryptVerify(password, hash);
}

// ============================================
// PASSWORD STRENGTH CHECKER
// ============================================

struct PasswordStrength {
    score: int,        // 0-4 (weak to strong)
    feedback: string,
    hasLower: bool,
    hasUpper: bool,
    hasDigit: bool,
    hasSpecial: bool,
    length: int
}

fn checkPasswordStrength(password) {
    let result = PasswordStrength {
        score: 0,
        feedback: "",
        hasLower: false,
        hasUpper: false,
        hasDigit: false,
        hasSpecial: false,
        length: 0
    };
    
    if (isNull(password)) {
        result.feedback = "Password is required";
        return result;
    }
    
    result.length = len(password);
    
    let i = 0;
    while (i < len(password)) {
        let c = charAt(password, i);
        let code = charCodeAt(password, i);
        
        // Check character types
        if (code >= 97 && code <= 122) {  // a-z
            result.hasLower = true;
        } else if (code >= 65 && code <= 90) {  // A-Z
            result.hasUpper = true;
        } else if (code >= 48 && code <= 57) {  // 0-9
            result.hasDigit = true;
        } else {
            result.hasSpecial = true;
        }
        
        i = i + 1;
    }
    
    // Calculate score
    let score = 0;
    
    // Length score
    if (result.length >= 8) { score = score + 1; }
    if (result.length >= 12) { score = score + 1; }
    
    // Character variety
    if (result.hasLower && result.hasUpper) { score = score + 1; }
    if (result.hasDigit) { score = score + 1; }
    if (result.hasSpecial) { score = score + 1; }
    
    // Cap at 4
    if (score > 4) { score = 4; }
    result.score = score;
    
    // Generate feedback
    if (score == 0) {
        result.feedback = "Very weak - add more characters";
    } else if (score == 1) {
        result.feedback = "Weak - add uppercase, numbers, or symbols";
    } else if (score == 2) {
        result.feedback = "Fair - consider adding more variety";
    } else if (score == 3) {
        result.feedback = "Good - strong password";
    } else {
        result.feedback = "Excellent - very strong password";
    }
    
    return result;
}
