// ============================================
// CRYO EVENT LOOP LIBRARY
// Event-driven programming patterns
// Version: 1.0.0
// ============================================

// ============================================
// EVENT LOOP STATE
// ============================================

let _eventQueue = [];
let _timers = [];
let _immediates = [];
let _nextTickQueue = [];
let _isRunning = false;
let _tickCount = 0;
let _maxTicks = 1000;

// Timer ID counter
let _timerIdCounter = 0;

// ============================================
// IMMEDIATE EXECUTION
// ============================================

// Schedule callback for immediate execution (next tick)
fn setImmediate(callbackName, arg) {
    let immediate = {};
    immediate["callback"] = callbackName;
    immediate["arg"] = arg;
    push(_immediates, immediate);
    return len(_immediates) - 1;
}

// Clear an immediate
fn clearImmediate(id) {
    if (id >= 0 && id < len(_immediates)) {
        _immediates[id] = null;
    }
}

// ============================================
// NEXT TICK (High priority)
// ============================================

// Schedule for next tick (runs before timers/immediates)
fn nextTick(callbackName, arg) {
    let tick = {};
    tick["callback"] = callbackName;
    tick["arg"] = arg;
    push(_nextTickQueue, tick);
}

// ============================================
// TIMER SIMULATION
// ============================================

// Schedule a timeout (simulated - returns timer ID)
fn setTimeout(callbackName, delayMs, arg) {
    _timerIdCounter = _timerIdCounter + 1;
    let timer = {};
    timer["id"] = _timerIdCounter;
    timer["callback"] = callbackName;
    timer["delay"] = delayMs;
    timer["arg"] = arg;
    timer["type"] = "timeout";
    timer["cancelled"] = false;
    push(_timers, timer);
    return _timerIdCounter;
}

// Schedule an interval (simulated - returns timer ID)
fn setInterval(callbackName, intervalMs, arg) {
    _timerIdCounter = _timerIdCounter + 1;
    let timer = {};
    timer["id"] = _timerIdCounter;
    timer["callback"] = callbackName;
    timer["delay"] = intervalMs;
    timer["arg"] = arg;
    timer["type"] = "interval";
    timer["cancelled"] = false;
    push(_timers, timer);
    return _timerIdCounter;
}

// Clear a timeout
fn clearTimeout(timerId) {
    let i = 0;
    while (i < len(_timers)) {
        if (_timers[i] != null && _timers[i]["id"] == timerId) {
            _timers[i]["cancelled"] = true;
        }
        i = i + 1;
    }
}

// Clear an interval
fn clearInterval(timerId) {
    clearTimeout(timerId);
}

// ============================================
// EVENT QUEUE
// ============================================

// Emit an event to the queue
fn emit(eventName, data) {
    let event = {};
    event["name"] = eventName;
    event["data"] = data;
    event["timestamp"] = getCurrentTime();
    push(_eventQueue, event);
}

// Get pending event count
fn pendingEvents() {
    return len(_eventQueue);
}

// Get pending timer count
fn pendingTimers() {
    let count = 0;
    let i = 0;
    while (i < len(_timers)) {
        if (_timers[i] != null && _timers[i]["cancelled"] == false) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

// ============================================
// EVENT LOOP EXECUTION
// ============================================

// Process one tick of the event loop
fn tick() {
    _tickCount = _tickCount + 1;
    let processed = 0;
    
    // 1. Process nextTick queue (highest priority)
    while (len(_nextTickQueue) > 0) {
        let item = _nextTickQueue[0];
        // Remove first item
        let newQueue = [];
        let i = 1;
        while (i < len(_nextTickQueue)) {
            push(newQueue, _nextTickQueue[i]);
            i = i + 1;
        }
        _nextTickQueue = newQueue;
        
        if (item != null) {
            processed = processed + 1;
        }
    }
    
    // 2. Process immediates
    let processedImmediates = [];
    let i = 0;
    while (i < len(_immediates)) {
        if (_immediates[i] != null) {
            push(processedImmediates, _immediates[i]);
            _immediates[i] = null;
        }
        i = i + 1;
    }
    processed = processed + len(processedImmediates);
    
    // 3. Process timers (simulate - in real impl would check time)
    i = 0;
    while (i < len(_timers)) {
        let timer = _timers[i];
        if (timer != null && timer["cancelled"] == false) {
            processed = processed + 1;
            
            if (timer["type"] == "timeout") {
                timer["cancelled"] = true;
            }
        }
        i = i + 1;
    }
    
    // 4. Process events
    while (len(_eventQueue) > 0) {
        let event = _eventQueue[0];
        // Remove first event
        let newQueue = [];
        let j = 1;
        while (j < len(_eventQueue)) {
            push(newQueue, _eventQueue[j]);
            j = j + 1;
        }
        _eventQueue = newQueue;
        processed = processed + 1;
    }
    
    return processed;
}

// Run the event loop until empty or max ticks
fn run() {
    _isRunning = true;
    _tickCount = 0;
    
    while (_isRunning && _tickCount < _maxTicks) {
        let processed = tick();
        
        // Check if anything left to process
        if (processed == 0 && pendingTimers() == 0 && pendingEvents() == 0) {
            break;
        }
    }
    
    _isRunning = false;
    return _tickCount;
}

// Run for specific number of ticks
fn runTicks(count) {
    let executed = 0;
    while (executed < count) {
        tick();
        executed = executed + 1;
    }
    return executed;
}

// Stop the event loop
fn stop() {
    _isRunning = false;
}

// ============================================
// STATUS CHECKS
// ============================================

fn isRunning() {
    return _isRunning;
}

fn getTickCount() {
    return _tickCount;
}

fn setMaxTicks(max) {
    _maxTicks = max;
}

// ============================================
// CLEANUP
// ============================================

fn reset() {
    _eventQueue = [];
    _timers = [];
    _immediates = [];
    _nextTickQueue = [];
    _isRunning = false;
    _tickCount = 0;
    _timerIdCounter = 0;
}

// ============================================
// UTILITY
// ============================================

fn getCurrentTime() {
    return 1736665200;
}

fn eventLoopVersion() {
    return "1.0.0";
}
