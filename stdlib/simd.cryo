// ============================================
// CRYO SIMD-LIKE OPERATIONS LIBRARY
// Vectorized array operations for performance
// Version: 1.0.0
// ============================================

// ============================================
// VECTOR MATH OPERATIONS
// ============================================

// Add two arrays element-wise
fn vecAdd(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        push(result, a[i] + b[i]);
        i = i + 1;
    }
    return result;
}

// Subtract two arrays element-wise
fn vecSub(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        push(result, a[i] - b[i]);
        i = i + 1;
    }
    return result;
}

// Multiply two arrays element-wise
fn vecMul(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        push(result, a[i] * b[i]);
        i = i + 1;
    }
    return result;
}

// Divide two arrays element-wise
fn vecDiv(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        if (b[i] != 0) {
            push(result, a[i] / b[i]);
        } else {
            push(result, 0);
        }
        i = i + 1;
    }
    return result;
}

// Scale array by scalar
fn vecScale(arr, scalar) {
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        push(result, arr[i] * scalar);
        i = i + 1;
    }
    return result;
}

// ============================================
// REDUCTION OPERATIONS
// ============================================

// Sum all elements
fn vecSum(arr) {
    let total = 0;
    let i = 0;
    while (i < len(arr)) {
        total = total + arr[i];
        i = i + 1;
    }
    return total;
}

// Product of all elements
fn vecProduct(arr) {
    if (len(arr) == 0) {
        return 0;
    }
    let total = 1;
    let i = 0;
    while (i < len(arr)) {
        total = total * arr[i];
        i = i + 1;
    }
    return total;
}

// Find minimum
fn vecMin(arr) {
    if (len(arr) == 0) {
        return null;
    }
    let minVal = arr[0];
    let i = 1;
    while (i < len(arr)) {
        if (arr[i] < minVal) {
            minVal = arr[i];
        }
        i = i + 1;
    }
    return minVal;
}

// Find maximum
fn vecMax(arr) {
    if (len(arr) == 0) {
        return null;
    }
    let maxVal = arr[0];
    let i = 1;
    while (i < len(arr)) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
        i = i + 1;
    }
    return maxVal;
}

// Calculate mean
fn vecMean(arr) {
    if (len(arr) == 0) {
        return 0;
    }
    return vecSum(arr) / len(arr);
}

// Dot product
fn vecDot(a, b) {
    let products = vecMul(a, b);
    return vecSum(products);
}

// ============================================
// COMPARISON OPERATIONS
// ============================================

// Element-wise equality (returns array of 0/1)
fn vecEq(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        if (a[i] == b[i]) {
            push(result, 1);
        } else {
            push(result, 0);
        }
        i = i + 1;
    }
    return result;
}

// Element-wise greater than
fn vecGt(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        if (a[i] > b[i]) {
            push(result, 1);
        } else {
            push(result, 0);
        }
        i = i + 1;
    }
    return result;
}

// Element-wise less than
fn vecLt(a, b) {
    let result = [];
    let length = len(a);
    if (len(b) < length) {
        length = len(b);
    }
    
    let i = 0;
    while (i < length) {
        if (a[i] < b[i]) {
            push(result, 1);
        } else {
            push(result, 0);
        }
        i = i + 1;
    }
    return result;
}

// ============================================
// GENERATION OPERATIONS
// ============================================

// Create array of zeros
fn vecZeros(n) {
    let result = [];
    let i = 0;
    while (i < n) {
        push(result, 0);
        i = i + 1;
    }
    return result;
}

// Create array of ones
fn vecOnes(n) {
    let result = [];
    let i = 0;
    while (i < n) {
        push(result, 1);
        i = i + 1;
    }
    return result;
}

// Create array with constant value
fn vecFill(n, value) {
    let result = [];
    let i = 0;
    while (i < n) {
        push(result, value);
        i = i + 1;
    }
    return result;
}

// Create range array [start, start+1, ..., end-1]
fn vecRange(start, end) {
    let result = [];
    let i = start;
    while (i < end) {
        push(result, i);
        i = i + 1;
    }
    return result;
}

// Create range with step
fn vecRangeStep(start, end, step) {
    let result = [];
    let i = start;
    while (i < end) {
        push(result, i);
        i = i + step;
    }
    return result;
}

// ============================================
// TRANSFORM OPERATIONS
// ============================================

// Apply absolute value
fn vecAbs(arr) {
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        let val = arr[i];
        if (val < 0) {
            val = 0 - val;
        }
        push(result, val);
        i = i + 1;
    }
    return result;
}

// Clamp values between min and max
fn vecClamp(arr, minVal, maxVal) {
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        let val = arr[i];
        if (val < minVal) {
            val = minVal;
        }
        if (val > maxVal) {
            val = maxVal;
        }
        push(result, val);
        i = i + 1;
    }
    return result;
}

// Normalize array (0 to 1 range)
fn vecNormalize(arr) {
    let minVal = vecMin(arr);
    let maxVal = vecMax(arr);
    let range = maxVal - minVal;
    
    if (range == 0) {
        return vecZeros(len(arr));
    }
    
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        push(result, (arr[i] - minVal) / range);
        i = i + 1;
    }
    return result;
}

// Reverse array
fn vecReverse(arr) {
    let result = [];
    let i = len(arr) - 1;
    while (i >= 0) {
        push(result, arr[i]);
        i = i - 1;
    }
    return result;
}

// ============================================
// FILTER OPERATIONS
// ============================================

// Filter by mask (keep where mask is 1)
fn vecFilter(arr, mask) {
    let result = [];
    let i = 0;
    while (i < len(arr) && i < len(mask)) {
        if (mask[i] == 1) {
            push(result, arr[i]);
        }
        i = i + 1;
    }
    return result;
}

// Count non-zero elements
fn vecCountNonZero(arr) {
    let count = 0;
    let i = 0;
    while (i < len(arr)) {
        if (arr[i] != 0) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

// Find indices where condition is true (value != 0)
fn vecWhere(arr) {
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        if (arr[i] != 0) {
            push(result, i);
        }
        i = i + 1;
    }
    return result;
}

// ============================================
// MATRIX OPERATIONS (2D as 1D with dimensions)
// ============================================

// Matrix multiply (flat arrays with dimensions)
fn matMul(a, aRows, aCols, b, bRows, bCols) {
    if (aCols != bRows) {
        return [];
    }
    
    let result = vecZeros(aRows * bCols);
    
    let i = 0;
    while (i < aRows) {
        let j = 0;
        while (j < bCols) {
            let sum = 0;
            let k = 0;
            while (k < aCols) {
                sum = sum + a[i * aCols + k] * b[k * bCols + j];
                k = k + 1;
            }
            result[i * bCols + j] = sum;
            j = j + 1;
        }
        i = i + 1;
    }
    
    return result;
}

// Transpose matrix (flat array)
fn matTranspose(arr, rows, cols) {
    let result = vecZeros(rows * cols);
    
    let i = 0;
    while (i < rows) {
        let j = 0;
        while (j < cols) {
            result[j * rows + i] = arr[i * cols + j];
            j = j + 1;
        }
        i = i + 1;
    }
    
    return result;
}

// ============================================
// MODULE INFO
// ============================================

fn simdVersion() {
    return "1.0.0";
}
